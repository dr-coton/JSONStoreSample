"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Store = void 0;
const tslib_1 = require("tslib");
const kind_of_1 = tslib_1.__importDefault(require("kind-of"));
const path_1 = tslib_1.__importDefault(require("path"));
const proper_lockfile_1 = tslib_1.__importDefault(require("proper-lockfile"));
const util_1 = require("util");
const fs_1 = require("./fs-impl/fs");
const constants_1 = require("./constants");
class Store {
    constructor(options) {
        var _a, _b, _c, _d;
        this.options = Object.freeze(Object.assign(Object.assign({}, options), { fs: (_a = options.fs) !== null && _a !== void 0 ? _a : fs_1.fs, lockfileRealpath: (_b = options.lockfileRealpath) !== null && _b !== void 0 ? _b : false }));
        this.serialize = (_c = options.serialize) !== null && _c !== void 0 ? _c : ((data) => Buffer.from(JSON.stringify(data)));
        this.deserialize = (_d = options.deserialize) !== null && _d !== void 0 ? _d : ((data) => JSON.parse(Buffer.from(data).toString()));
        this.properLockfileFs = this.callbackifyFsImpl();
    }
    get adapter() {
        return this.options.adapter;
    }
    get file() {
        return this.options.file;
    }
    get fs() {
        return this.options.fs;
    }
    get optimisticLocking() {
        return this.options.optimisticLocking || false;
    }
    get validators() {
        return this.options.validators;
    }
    clone(opts) {
        var _a;
        return new Store(Object.assign(Object.assign(Object.assign({}, this.options), opts), { 
            // enforcing options state to always have the "file" property filled
            file: path_1.default.resolve((_a = opts === null || opts === void 0 ? void 0 : opts.file) !== null && _a !== void 0 ? _a : this.file) }));
    }
    async readable() {
        let fd;
        try {
            fd = await this.fs.open(this.file, "r+");
        }
        catch (error) {
            if (error.code === constants_1.FS_ERROR_CODE_ENOENT) {
                return false;
            }
            throw error;
        }
        await this.fs.close(fd);
        return true;
    }
    async readExisting(options) {
        const response = await this.read(options);
        if (!response) {
            throw new Error(`${this.file} does not exist`);
        }
        return response;
    }
    async read(options) {
        var _a;
        const readable = await this.readable();
        if (!readable) {
            return null;
        }
        const buffer = await this.fs.readFile(this.file);
        const adapter = (_a = (options && options.adapter)) !== null && _a !== void 0 ? _a : this.adapter;
        const adaptedBuffer = adapter ? await adapter.read(buffer) : buffer;
        const data = this.deserialize(adaptedBuffer);
        await this.validate(data, "Reading validation: ");
        return data;
    }
    async write(data, options) {
        const dataType = kind_of_1.default(data);
        const dir = path_1.default.dirname(this.file);
        if (this.optimisticLocking && dataType !== "object") {
            throw new Error([
                `With the optimistic locking enabled stored data must be of the "object" type, `,
                `while passed for writing data is of the "${dataType}" type.`,
            ].join(""));
        }
        await this.validate(data, "Writing validation: ");
        try {
            await this.fs.stat(dir);
        }
        catch (err) {
            if (err.code === constants_1.FS_ERROR_CODE_ENOENT) {
                await this.mkdirRecursive(dir);
            }
            else {
                throw err;
            }
        }
        const finalAction = async (dataToSave) => {
            const buffer = Buffer.from(this.serialize(dataToSave));
            const adaptedBuffer = this.adapter ? await this.adapter.write(buffer) : buffer;
            await this.fs.writeFileAtomic(this.file, adaptedBuffer);
            return this.readExisting();
        };
        if (this.optimisticLocking) {
            const nextRevision = await this.resolveNewRevision(data, options && options.readAdapter);
            const lockfilePath = this.resolveLockfilePath();
            const releaseLock = await proper_lockfile_1.default.lock(this.file, Object.assign({ fs: this.properLockfileFs, realpath: this.options.lockfileRealpath }, (lockfilePath && { lockfilePath })));
            try {
                return await finalAction(Object.assign({}, data, { _rev: nextRevision }));
            }
            finally {
                await releaseLock();
            }
        }
        return await finalAction(data);
    }
    async validate(data, messagePrefix) {
        if (!this.validators || !this.validators.length) {
            return;
        }
        for (const validator of this.validators) {
            const invalidMessage = await validator(data);
            if (invalidMessage !== null) {
                throw new Error(`${messagePrefix || ""}${invalidMessage}`);
            }
        }
    }
    async remove() {
        await this.fs.unlink(this.file);
    }
    resolveLockfilePath() {
        var _a;
        return (_a = this.options.lockfilePathResolver) === null || _a === void 0 ? void 0 : _a.call(this, this.file);
    }
    async resolveNewRevision(payloadData, readAdapter) {
        const { _rev: payloadRev } = payloadData;
        const storedData = await this.read({ adapter: readAdapter });
        if (!storedData) {
            return typeof payloadRev === "number" ? payloadRev : 0;
        }
        const { _rev: storedRev } = storedData;
        // TODO TS doesn't understand constant based "typeof" type guards
        const payloadDataVersioned = typeof payloadRev === "number";
        const storedDataVersioned = typeof storedRev === "number";
        if (!storedDataVersioned && payloadDataVersioned) {
            throw new Error(`Version value (${payloadRev}) can't be passed for updating unversioned file "${this.file}"`);
        }
        if (!storedDataVersioned || typeof payloadRev !== "number" || storedRev !== payloadRev) {
            throw new Error([
                `"${this.file}" has been updated by another process. `,
                `Revisions of the persisted (${storedRev}) and payload (${payloadRev}) data don't match`,
            ].join(""));
        }
        return storedRev + 1;
    }
    async mkdirRecursive(value) {
        const folderNames = value.split(path_1.default.sep);
        const pathsToCreate = [];
        for (let i = 0; i < folderNames.length; i++) {
            const partialPath = folderNames
                .slice(0, folderNames.length - i)
                .join(path_1.default.sep);
            try {
                if ((await this.fs.stat(partialPath)).isDirectory()) {
                    break;
                }
            }
            catch (err) {
                if (err.code !== constants_1.FS_ERROR_CODE_ENOENT) {
                    throw err;
                }
            }
            if (partialPath) {
                pathsToCreate.push(partialPath);
            }
        }
        pathsToCreate.reverse();
        for (const pathToCreate of pathsToCreate) {
            try {
                await this.fs.mkdir(pathToCreate, constants_1.MKDIR_MODE);
            }
            catch (error) {
                if (error.code !== constants_1.FS_ERROR_CODE_EEXIST) { // directory might already be created by another/parallel process
                    throw error;
                }
            }
        }
    }
    callbackifyFsImpl() {
        return Object
            .keys(this.fs._impl)
            .filter((key) => typeof this.fs._impl[key] === "function")
            .reduce((accumulator, key) => {
            accumulator[key] = util_1.callbackify(this.fs._impl[key]);
            return accumulator;
        }, {});
    }
}
exports.Store = Store;
//# sourceMappingURL=store.js.map